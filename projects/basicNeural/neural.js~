let testlength = 2000;
let fitnesses = {
    columns: [
        ["Best"],
        ["Average"]
    ],
    length: 0
};
let skipAnim;
let asap;
let couldNot = false;
let first = true;

let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");
ctx.fillStyle = "grey";
ctx.fillRect(0, 0, canvas.width, canvas.height);

var chart;
chart = c3.generate({
    bindto: "#chart",
    data: fitnesses,
    /*size: {
        height: 600,
        width: 500
    },*/
    transition: {
        duration: 0
    },
    interaction: {
        enabled: true
    },
    axis: {
        y: {
            // Range includes padding, set 0 if no padding needed
            padding: {
                top: 50,
                bottom: 0
            }
        }
    }
});

document.getElementById("nextGen").onclick = doGen;
document.getElementById("skipAnim").onclick = toggleSkipAnim;
document.getElementById("asap").onclick = toggleAsap;


let neuralWorker = new Worker("neuralWorker.js");
neuralWorker.onmessage = function(e) {
    //console.log(e.data);
    if (e.data == "notRunning") {
        if (couldNot) {
            couldNot = false;
            doGen();
        }
    } else if (e.data == "running") {
        couldNot = true;
    } else {
        fitnesses.columns[0][1] = e.data[0];
        fitnesses.columns[1][1] = e.data[1];
        drawFitness(fitnesses);

        let displayBall = new Ball(canvas.height / 2, canvas.width / 2);
        displayBall.net.putWeights(e.data[2]);
        drawBallAnimation(displayBall);
    }
};


function doGen() {
    neuralWorker.postMessage("doGen");
    //Fitness drawing
    /*fitnesses.columns[0].push(ballPopulation.population[0].fitness);
    fitnesses.columns[1].push(ballPopulation.getAverage());
    drawFitness(fitnesses);

    drawBallAnimation();*/
}

function drawFitness(fitnessData) {
    chart.flow(fitnessData);
}

function getLargest(array) {
    let max = 0;
    array.forEach((n) => {
        if (array[i][0] > max) {
            max = array[i][0];
        }
    });
    /*for (var i = 0; i < array.length; i++) {
        if (array[i][0] > max) {
            max = array[i][0];
        }
    }*/
    return max;
}

function drawBallAnimation(ball) {

    let counter = 0;
    let score = 0;
    let point = [canvas.width * Math.random(), canvas.height * Math.random()];
    ball.x = canvas.width / 2;
    ball.y = canvas.width / 2;
    let prevSpot = [canvas.width / 2, canvas.height / 2];
    let loop = setInterval(function() {
            if (skipAnim === true) {
                clearInterval(loop);
                if (asap) {
                    doGen();
                }
            }

            drawBackground(canvas, "grey");
            ball.update(point);
            ball.draw(ctx);
            drawPoint(canvas, point, "blue");
            displayText(canvas, "Score: " + score.toFixed(2) + " Frame " + counter + ":" + testlength, "blue")

            if (ball.x > 0 && ball.y > 0 && ball.x < canvas.width && ball.y < canvas.height) {

                if (Math.abs(prevSpot[0] - point[0]) > Math.abs(ball.x - point[0]) && Math.abs(prevSpot[1] - point[1]) > Math.abs(ball.y - point[1])) {
                    score += Math.abs(prevSpot[0] - ball.x) + Math.abs(prevSpot[1] - ball.y) / 10;
                }

                if (prevSpot[0] - ball.x == 0 && prevSpot[1] - ball.y == 0) {
                    clearInterval(loop);
                    if (asap) {
                        doGen();
                    };
                }

                prevSpot[0] = ball.x;
                prevSpot[1] = ball.y;


                if (Math.abs(point[0] - ball.x) < 15 && Math.abs(point[1] - ball.y) < 15) {
                    score += 10000;
                    point = [canvas.width * Math.random(), canvas.height * Math.random()];
                }
                counter++;
            } else {
                clearInterval(loop);
                if (asap) {
                    doGen();
                }
            }

            if (counter > testlength) {
                clearInterval(loop);
                if (asap) {
                    doGen();
                }
            }
        },
        5);
}

function procreate() {
    ballPopulation.generateNextGen();
    ballPopulation.mutate(0.2);
    running = false;
    if (asap === true) {
        doGen();
    }
}

function toggleAsap() {
    asap = (document.getElementById("asap").checked);
}

function toggleSkipAnim() {
    skipAnim = (document.getElementById("skipAnim").checked);
}

function displayText(canvas, text, color) {
    let ctx = canvas.getContext("2d");
    ctx.fillStyle = color;

    ctx.font = "20px Georgia";
    ctx.fillText(text, 5, 20);
}

function drawPoint(canvas, point, color) {
    let ctx = canvas.getContext("2d");
    ctx.fillStyle = color;

    ctx.beginPath();
    ctx.arc(point[0], point[1], 5, 0, 2 * Math.PI);
    ctx.fill();

}

function Neuron(numInputs) {
    this.numInputs = numInputs;
    this.weights = [];
    for (var i = 0; i < numInputs + 1; i++) {
        this.weights.push(Math.random() * 2 - 1);
    }
}

function NeuronLayer(numNeurons, numInputsPerNeuron) {
    this.numNeurons = numNeurons;
    this.neurons = [];

    for (var i = 0; i < this.numNeurons; i++) {
        this.neurons.push(new Neuron(numInputsPerNeuron));
    }
}

function NeuralNet() {
    this.numInputs;
    this.numOutputs;
    this.numHiddenLayers;
    this.neuronsPerHiddenLayer;

    this.layers = [];

    this.createnet = function(numInputs, numOutputs, numHiddenLayers, neuronsPerHiddenLayer) {

        this.numInputs = numInputs;
        this.numOutputs = numOutputs;
        this.numHiddenLayers = numHiddenLayers;
        this.neuronsPerHiddenLayer = neuronsPerHiddenLayer;

        if (numHiddenLayers > 0) {

            this.layers.push(new NeuronLayer(neuronsPerHiddenLayer, numInputs));

            for (var i = 0; i < numHiddenLayers - 1; i++) {
                this.layers.push(new NeuronLayer(neuronsPerHiddenLayer, this.layers[this.layers.length - 1].numNeurons));
            }
        }

        this.layers.push(new NeuronLayer(numOutputs, this.layers[this.layers.length - 1].numNeurons));

    };

    this.getWeights = function() {
        let weights = [];
        for (var i = 0; i < this.numHiddenLayers + 1; i++) {

            for (var j = 0; j < this.layers[i].numNeurons; j++) {

                for (var k = 0; k < this.layers[i].neurons[j].numInputs + 1; k++) {
                    weights.push(this.layers[i].neurons[j].weights[k]);
                }

            }
        }
        return weights;
    };

    this.getNumberOfWeights = function() {
        return this.getWeights().length;
    };

    this.putWeights = function(weights) {
        let count = 0;
        if (weights.length !== this.getNumberOfWeights()) {
            return "Must have same ammount as in the net";
        }
        for (var i = 0; i < this.numHiddenLayers + 1; i++) {

            for (var j = 0; j < this.layers[i].numNeurons; j++) {

                for (var k = 0; k < this.layers[i].neurons[j].numInputs + 1; k++) {
                    this.layers[i].neurons[j].weights[k] = weights[count++];
                }
            }
        }
    };

    this.update = function(inputs) {
        let outputs = [];
        let cWeight = 0;

        if (inputs.length !== this.numInputs) {
            return outputs;
        }

        for (var i = 0; i < this.numHiddenLayers + 1; i++) {

            if (i > 0) {
                inputs = outputs;
            }

            outputs = [];

            cWeight = 0;

            for (var j = 0; j < this.layers[i].numNeurons; j++) {
                let netinput = 0;

                let numInputs = this.layers[i].neurons[j].numInputs;
                for (var k = 0; k < numInputs; k++) {
                    netinput += this.layers[i].neurons[j].weights[k] * inputs[cWeight++];
                }

                netinput += this.layers[i].neurons[j].weights[numInputs - 1] * (-1);


                outputs.push(this.sigmoid(netinput, 1));


                cWeight = 0;
            }
        }
        return outputs;
    };

    this.sigmoid = function(activation, response) {
        return 1 / (1 + (Math.pow(Math.E, -activation / response)));
    };
}

function Ball(x, y) {
    this.x = x;
    this.y = y;
    this.dx;
    this.dy;
    this.radius = 10;
    this.color = "red";
    this.fitness = 0;

    this.net = new NeuralNet;

    this.net.createnet(4, 2, 1, 7);

    this.update = function(objective) {
        let output = this.net.update([this.x, this.y, objective[0], objective[1]]);
        this.dx = (output[0] * 2 - 1) * 8;
        this.dy = (output[1] * 2 - 1) * 8;

        this.x += this.dx;
        this.y += this.dy;
    }

    this.draw = function(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
    }
}

function drawBackground(canvas, color) {
    let ctx = canvas.getContext("2d");
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height)
}



function population(antall) {
    this.size = antall;
    this.population = [];

    for (var i = 0; i < this.size; i++) {
        this.population[i] = new Ball(canvas.height / 2, canvas.width / 2);
    }

    this.testFitness = function(testlength) {
        for (ball in this.population) {
            this.population[ball].fitness = 0;
            for (var k = 0; k < 3; k++) {
                let point = [canvas.width * Math.random(), canvas.height * Math.random()];
                let prevSpot = [canvas.width / 2, canvas.height / 2];
                this.population[ball].x = canvas.width / 2;
                this.population[ball].y = canvas.height / 2;
                for (var i = 0; i < testlength; i++) {
                    this.population[ball].update(point);

                    if (this.population[ball].x < canvas.width && this.population[ball].y < canvas.height && this.population[ball].y > 0 && this.population[ball].x > 0) {

                        if (Math.abs(prevSpot[0] - point[0]) > Math.abs(this.population[ball].x - point[0]) && Math.abs(prevSpot[1] - point[1]) > Math.abs(this.population[ball].y - point[1])) {
                            this.population[ball].fitness += Math.abs(prevSpot[0] - this.population[ball].x) + Math.abs(prevSpot[1] - this.population[ball].y) / 10;
                        }

                        if (prevSpot[0] - this.population[ball].x === 0 && prevSpot[1] - this.population[ball].y === 0) {
                            break;
                        }

                        prevSpot[0] = this.population[ball].x;
                        prevSpot[1] = this.population[ball].y;
                        if (Math.abs(point[0] - this.population[ball].x) < 15 && Math.abs(point[1] - this.population[ball].y) < 15) {
                            this.population[ball].fitness += 10000;
                            point = [canvas.width * Math.random(), canvas.height * Math.random()];
                        }
                    } else {
                        break;
                    }
                }
            }
            this.population[ball].fitness /= 3;
        }
    }

    this.mutate = function(ammount) {
        let tempWeights = [];
        for (ball in this.population) {
            tempWeights = this.population[ball].net.getWeights();
            for (weight in tempWeights) {
                tempWeights[weight] += (Math.random() * 2 - 1) * ammount;
            }
            this.population[ball].net.putWeights(tempWeights);
        }
    }

    this.sortByFitness = function() {
        this.population.sort(function(ball1, ball2) {
            return parseInt(ball2.fitness) - parseInt(ball1.fitness);
        });
    }

    this.getAverage = function() {
        let tempSum = 0;

        for (ball in this.population) {
            tempSum += this.population[ball].fitness;
        }

        return tempSum / this.population.length;
    }


    this.generateNextGen = function() {
        let tempPopualtion = [];
        let sum = 0;
        let prevProb = 0;

        for (ball in this.population) {
            sum += this.population[ball].fitness;
        }
        for (var i = 0; i < this.population.length; i++) {
            let thisFitness = this.population[i].fitness;
            this.population[i].fitness = prevProb + (thisFitness / sum)
            prevProb += (thisFitness / sum);
        }

        while (tempPopualtion.length < this.size) {

            let parent1 = Math.random() - 0.01;
            for (var i = 0; i < this.population.length; i++) {
                if (parent1 < this.population[i].fitness) {
                    parent1 = i;
                    break;
                }
            }

            let parent2 = Math.random() - 0.01;
            for (var i = 0; i < this.population.length; i++) {
                if (parent2 < this.population[i].fitness) {
                    parent2 = i;
                    break;
                }
            }

            tempPopualtion.push(this.crossover(this.population[parent1], this.population[parent2]));
        }

        this.population = tempPopualtion;
    }

    this.crossover = function(ball1, ball2) {
        tempBall = new Ball(canvas.width / 2, canvas.height / 2);
        let parent1Genes = ball1.net.getWeights();
        let parent2Genes = ball2.net.getWeights();
        let cutoff = Math.floor(Math.random() * parent1Genes.length);

        parent1Genes = parent1Genes.slice(0, cutoff);
        parent2Genes = parent2Genes.slice(cutoff, parent2Genes.length);

        tempBall.net.putWeights(parent1Genes.concat(parent2Genes));
        return tempBall;

    }

}
